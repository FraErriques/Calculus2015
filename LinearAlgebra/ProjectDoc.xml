<?xml version="1.0"?>
<doc>
    <assembly>
        <name>LinearAlgebra</name>
    </assembly>
    <members>
        <member name="T:LinearAlgebra.PointR3">
            <summary>
            a point vector, in R3.
            </summary>
        </member>
        <member name="M:LinearAlgebra.PointR3.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            public access point: Ctor( coordinates).
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
        </member>
        <member name="M:LinearAlgebra.PointR3.#ctor(System.Double[])">
            <summary>
            public access point: Ctor.
            </summary>
            <param name="thePointCoordinates"></param>
        </member>
        <member name="M:LinearAlgebra.PointR3.#ctor(LinearAlgebra.PointR3)">
            <summary>
            copy Ctor.
            </summary>
            <param name="theOriginal">the original, from which to copy.</param>
        </member>
        <member name="M:LinearAlgebra.PointR3.getPointVector">
            <summary>
            get the three coordinates, as a vector. 
            </summary>
        </member>
        <member name="M:LinearAlgebra.PointR3.omothetia(System.Double)">
            <summary>
            product of a scalar for a vector, i.e. omothetia of a vector.
            </summary>
        </member>
        <member name="M:LinearAlgebra.PointR3.scalarProduct(LinearAlgebra.PointR3)">
            <summary>
            scalar product between this and w.
            </summary>
            <param name="w">the second factor; the first factor is "this"</param>
            <returns></returns>
        </member>
        <member name="M:LinearAlgebra.PointR3.NormaEuclidea">
            <summary>
            |this|==(this_scalar_this)^(1/2).
            </summary>
            <returns>the vector length</returns>
        </member>
        <member name="M:LinearAlgebra.PointR3.vectorProduct(LinearAlgebra.PointR3)">
            <summary>
            vector product between this and w.
            </summary>
            <param name="w">the second factor; the first factor is "this"</param>
            <returns></returns>
        </member>
        <member name="P:LinearAlgebra.PointR3.getX">
            <summary>
            get the Abscissa
            </summary>
        </member>
        <member name="P:LinearAlgebra.PointR3.getY">
            <summary>
            get the Ordinate
            </summary>
        </member>
        <member name="P:LinearAlgebra.PointR3.getZ">
            <summary>
            get the Height
            </summary>
        </member>
        <member name="P:LinearAlgebra.PointR3.getPointCoordinates">
            <summary>
            get the three coordinates in one-shot 
            </summary>
        </member>
        <member name="T:LinearAlgebra.MatrixRank">
            <summary>
            a son class, intended to evaluate the MatrixRank of the father RealMatrix.
            </summary>
        </member>
        <member name="T:LinearAlgebra.RealMatrix">
            <summary>
            a Matrix of real numbers (double type)
            manages both square and rectangular matrices
            determinant
            inversion
            main feature is : Jordan Gauss elimination.
            </summary>
        </member>
        <member name="F:LinearAlgebra.RealMatrix.rows">
            <summary>
            lines cardinality.
            </summary>
        </member>
        <member name="F:LinearAlgebra.RealMatrix.cols">
            <summary>
            lines cardinality.
            </summary>
        </member>
        <member name="F:LinearAlgebra.RealMatrix.m">
            <summary>
            the Tensor.
            </summary>
        </member>
        <member name="M:LinearAlgebra.RealMatrix.#ctor(System.Int32,System.Int32)">
            <summary>
            Ctor : only specify rowsXcols, and get a zeros-filled matrix.
            </summary>
            <param name="Prows"></param>
            <param name="Pcols"></param>
        </member>
        <member name="M:LinearAlgebra.RealMatrix.#ctor(System.Int32,System.Int32,System.String)">
            <summary>
            Ctor : deserialize from a stream.
            </summary>
            <param name="Prows"></param>
            <param name="Pcols"></param>
            <param name="where"></param>
        </member>
        <member name="M:LinearAlgebra.RealMatrix.#ctor(System.Double[0:,0:],System.Int32,System.Int32)">
            <summary>
            get the memory-address of a variable already containing an appropriate double[,].
            </summary>
            <param name="prototype">the appropriate double[,]</param>
            <param name="Prows">rows</param>
            <param name="Pcols">columns</param>
        </member>
        <member name="M:LinearAlgebra.RealMatrix.#ctor(System.Int32,System.Int32,System.Boolean,System.String)">
            <summary>
            create in RAM and, if desired, dump on a file. Tou can choose to randomize.
            </summary>
            <param name="Prows"></param>
            <param name="Pcols"></param>
            <param name="randomized"></param>
            <param name="where"></param>
        </member>
        <member name="M:LinearAlgebra.RealMatrix.#ctor(LinearAlgebra.RealMatrix)">
            <summary>
            Copy Constructor
            </summary>
            <param name="original"></param>
        </member>
        <member name="M:LinearAlgebra.RealMatrix.#ctor(LinearAlgebra.RealMatrix,System.Int32,System.Int32)">
            <summary>
            Copy Constructor, with row exchange. Determinant preserved via a sign exchange.
            
                 ooooooooo                  ooooooooo
                 ooooooooo                  ooooooooo
                 o from  o                  o  -to  o
                 ooooooooo ----------->     ooooooooo
                 o  to   o                  o from  o
                 ooooooooo                  ooooooooo
            
            </summary>
            <param name="original">the original matrix, before the row exchange</param>
            <param name="from">the position of the row to be moved</param>
            <param name="to">the position of the destination where to move the row</param>
        </member>
        <member name="M:LinearAlgebra.RealMatrix.#ctor(LinearAlgebra.RealMatrix,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Copy Constructor, with column exchange. Determinant preserved via a sign exchange.
            
                    ooooooooooo                 ooooooooooo
                    ooooooooooo                 ooooooooooo
                    o   ooo  oo                 o   ooo   o
                    o f ooo   o                 o - ooo f o
                    o r ooo t o                 o t ooo r o
                    o o ooo o o ----------->    o o ooo o o
                    o m ooo   o                 o   ooo m o
                    o   ooo   o                 o   ooo   o
                    ooooooooooo                 ooooooooooo
                    ooooooooooo                 ooooooooooo
            
            </summary>
            <param name="original">the original matrix, before the column exchange</param>
            <param name="from">the position of the column to be moved</param>
            <param name="to">the position of the destination where to move the column</param>
            <param name="isOnColumn"> this is a flag-parameter, which is neither evaluated. Its mere presence indicates that the exchange indexes indicate columns.</param>
        </member>
        <member name="M:LinearAlgebra.RealMatrix.Finalize">
            <summary>
            Destructor.
            </summary>
        </member>
        <member name="M:LinearAlgebra.RealMatrix.deallocate">
            <summary>
            called by the Destructor: it frees the memory of the underlying matrix.
            </summary>
        </member>
        <member name="M:LinearAlgebra.RealMatrix.deallocator_publicProxy">
            <summary>
            a public Proxy for deallocate()
            </summary>
        </member>
        <member name="M:LinearAlgebra.RealMatrix.det(LinearAlgebra.RealMatrix@)">
            <summary>
            tringularize and then det(tringularized), delivering the triangular matrix, in a copy-variable,
            </summary>
            <param name="copy"></param>
            <returns></returns>
        </member>
        <member name="M:LinearAlgebra.RealMatrix.det">
            <summary>
            tringularize and then det(tringularized), delivering only the scalar determinant.
            </summary>
            <returns></returns>
        </member>
        <member name="M:LinearAlgebra.RealMatrix.lineExchange(System.Int32,LinearAlgebra.RealMatrix@)">
            <summary>
            this call performs also the sign exchange: on line-exchange a sign exchange, on the elements of the moved line, is needed to preserve the determinant.
            </summary>
            <param name="diagonalCoordinates"></param>
            <param name="copyMatrix"></param>
            <returns></returns>
        </member>
        <member name="M:LinearAlgebra.RealMatrix.Gauss_Jordan_elimination">
            <summary>
            the main linear algebra technique.
            </summary>
            <returns></returns>
        </member>
        <member name="M:LinearAlgebra.RealMatrix.transpose">
            <summary>
            transpose "this".
            </summary>
            <returns>a copy, containing Transopose(this).</returns>
        </member>
        <member name="M:LinearAlgebra.RealMatrix.scalar(System.Double[],System.Double[])">
            <summary>
            the scalar product between vectors (isomorphic obviously)
            </summary>
            <param name="first"></param>
            <param name="second"></param>
            <returns></returns>
        </member>
        <member name="M:LinearAlgebra.RealMatrix.modulo(System.Double[])">
            <summary>
            due-norma; la norma indotta dal prodotto scalare negli spazi euclidei.
            e' la norma classica negli spazi di Hilbert.
            </summary>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:LinearAlgebra.RealMatrix.operator_mul(LinearAlgebra.RealMatrix)">
            <summary>
            prodotto righe per colonne.
            </summary>
            <param name="second"></param>
            <returns></returns>
        </member>
        <member name="M:LinearAlgebra.RealMatrix.operator_add(LinearAlgebra.RealMatrix)">
            end prodotto righe per colonne.
        </member>
        <member name="M:LinearAlgebra.RealMatrix.operator_assignment(LinearAlgebra.RealMatrix)">
            <summary>
            assigns an in-memory matrix(i.e. second) to "this".
            </summary>
            <param name="second"></param>
            <returns></returns>
        </member>
        <member name="M:LinearAlgebra.RealMatrix.element_assignment(System.Int32,System.Int32,System.Double)">
            <summary>
            assigns a scalar element, to the position (iRow,jCol)
            </summary>
            <param name="iRow">row position</param>
            <param name="jCol">col position</param>
            <param name="theElement">elemnt content</param>
            <returns>bool esito</returns>
        </member>
        <member name="M:LinearAlgebra.RealMatrix.reductor(System.Int32,System.Int32)">
            <summary>
            get a subMatrix, specifying which row and which column to eliminate.
            </summary>
            <param name="delendaRow"></param>
            <param name="delendaCol"></param>
            <returns></returns>
        </member>
        <member name="M:LinearAlgebra.RealMatrix.inverse">
            <summary>
            inversion, for non-singular square matrices. Trasposta del cofattore, diviso determinante.
            </summary>
            <returns></returns>
        </member>
        <member name="M:LinearAlgebra.RealMatrix.getRow(System.Int32)">
            <summary>
            get a row vector.
            </summary>
            <param name="theRow"></param>
            <returns></returns>
        </member>
        <member name="M:LinearAlgebra.RealMatrix.getCol(System.Int32)">
            <summary>
            get a column vector.
            </summary>
            <param name="theCol"></param>
            <returns></returns>
        </member>
        <member name="M:LinearAlgebra.RealMatrix.putCol(System.Int32,System.Double[])">
            <summary>
            write down a column content, at position "theCol-index".
            </summary>
            <param name="theCol">column index</param>
            <param name="colContent">xolumn content</param>
            <returns>false on invalid column index.</returns>
        </member>
        <member name="M:LinearAlgebra.RealMatrix.putRow(System.Int32,System.Double[])">
            <summary>
            write down a row content, at position "theRow-index".
            </summary>
            <param name="theRow">row index</param>
            <param name="rowContent">row content</param>
            <returns>false on invalid row index.</returns>
        </member>
        <member name="M:LinearAlgebra.RealMatrix.show">
            <summary>
            write a matrix on the Console.
            </summary>
        </member>
        <member name="M:LinearAlgebra.RealMatrix.show_LogSinkFs">
            <summary>
            write a matrix on the LogSinkFileSystem.
            </summary>
        </member>
        <member name="M:LinearAlgebra.RealMatrix.show(System.Double)">
            <summary>
            write a matrix on the Console.
            </summary>
        </member>
        <member name="M:LinearAlgebra.RealMatrix.input">
            <summary>
            read a matrix from the Console.
            </summary>
        </member>
        <member name="M:LinearAlgebra.RealMatrix.insert(System.Double,System.Int32,System.Int32)">
            <summary>
             insert a single element [row,col]
            </summary>
            <param name="what">the element, to be inserted.</param>
            <param name="row">the row coordinate of the insertion</param>
            <param name="col">the col coordinate of the insertion</param>
            <returns></returns>
        </member>
        <member name="M:LinearAlgebra.RealMatrix.readfileByChars(System.String)">
            <summary>
            deserialize a matrix, from a stream.
            </summary>
            <param name="where"></param>
            <returns></returns>
        </member>
        <member name="M:LinearAlgebra.RealMatrix.validate(System.Int32,System.Int32,System.String)">
            <summary>
            validation of a file content.
            </summary>
            <param name="validationRows">rows cardinality</param>
            <param name="validationCols">columns cardinality</param>
            <param name="where">file fullpath</param>
            <returns></returns>
        </member>
        <member name="M:LinearAlgebra.RealMatrix.readfileByTokens(System.Int32,System.Int32,System.String)">
            <summary>
            validation of a file content.
            </summary>
            <param name="validationRows">rows cardinality</param>
            <param name="validationCols">columns cardinality</param>
            <param name="where">file fullpath</param>
            <returns></returns>
        </member>
        <member name="M:LinearAlgebra.RealMatrix.writefile(System.String)">
            <summary>
            serialize a matrix on a stream.
            </summary>
            <param name="where"></param>
            <returns></returns>
        </member>
        <member name="M:LinearAlgebra.RealMatrix.Wolfram_writefile(System.String)">
            <summary>
            serialize a matrix on a stream, following the Wolfram convention, which enumerates vector elements within curl braces {}.
            </summary>
            <param name="where"></param>
            <returns></returns>
        </member>
        <member name="M:LinearAlgebra.RealMatrix.generator">
            <summary>
            randomize a matrix.
            </summary>
        </member>
        <member name="M:LinearAlgebra.RealMatrix.get_element(System.Int32,System.Int32)">
            <summary>
            gets the real number at coordinates Matrix[i,j]
            </summary>
            <param name="i"></param>
            <param name="j"></param>
            <returns></returns>
        </member>
        <member name="P:LinearAlgebra.RealMatrix.Get_rows">
            <summary>
            readonly row cardinality
            </summary>
        </member>
        <member name="P:LinearAlgebra.RealMatrix.Get_cols">
            <summary>
            readonly column cardinality
            </summary>
        </member>
        <member name="F:LinearAlgebra.MatrixRank.involvedDimensions">
            <summary>
            we don't know how many dimensions will be involved, until Rank is found.
            we should become certain about how many subMatrices we need to treat, in a single dimension. But it depends also on how quickly you fin a nonnul minor, so it's a dynamic data.
            </summary>
        </member>
        <member name="F:LinearAlgebra.MatrixRank.combinationParams">
            <summary>
            instance, of the class wide data.
            </summary>
        </member>
        <member name="M:LinearAlgebra.MatrixRank.#ctor(System.Int32,System.Int32)">
            <summary>
            Ctor
            </summary>
            <param name="Prows"></param>
            <param name="Pcols"></param>
        </member>
        <member name="M:LinearAlgebra.MatrixRank.#ctor(System.Int32,System.Int32,System.String)">
            <summary>
            Ctor : deserialize from a stream.
            </summary>
            <param name="Prows"></param>
            <param name="Pcols"></param>
            <param name="where"></param>
        </member>
        <member name="M:LinearAlgebra.MatrixRank.#ctor(System.Double[0:,0:],System.Int32,System.Int32)">
            <summary>
            get the memory-address of a variable already containing an appropriate double[,].
            </summary>
            <param name="prototype">the appropriate double[,]</param>
            <param name="Prows">Get_rows</param>
            <param name="Pcols">columns</param>
        </member>
        <member name="M:LinearAlgebra.MatrixRank.#ctor(System.Int32,System.Int32,System.Boolean,System.String)">
            <summary>
            create in RAM and, if desired, dump on a file. Tou can choose to randomize.
            </summary>
            <param name="Prows"></param>
            <param name="Pcols"></param>
            <param name="randomized"></param>
            <param name="where"></param>
        </member>
        <member name="M:LinearAlgebra.MatrixRank.#ctor(LinearAlgebra.RealMatrix)">
            <summary>
            Copy Constructor
            </summary>
            <param name="original"></param>
        </member>
        <member name="M:LinearAlgebra.MatrixRank.#ctor(LinearAlgebra.RealMatrix,System.Int32,System.Int32)">
            <summary>
            Copy Constructor, with row exchange. Determinant preserved via a sign exchange.
            
                 ooooooooo                  ooooooooo
                 ooooooooo                  ooooooooo
                 o from  o                  o  -to  o
                 ooooooooo ----------->     ooooooooo
                 o  to   o                  o from  o
                 ooooooooo                  ooooooooo
            
            </summary>
            <param name="original">the original matrix, before the row exchange</param>
            <param name="from">the position of the row to be moved</param>
            <param name="to">the position of the destination where to move the row</param>
        </member>
        <member name="M:LinearAlgebra.MatrixRank.#ctor(LinearAlgebra.RealMatrix,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Copy Constructor, with column exchange. Determinant preserved via a sign exchange.
            
                    ooooooooooo                 ooooooooooo
                    ooooooooooo                 ooooooooooo
                    o   ooo  oo                 o   ooo   o
                    o f ooo   o                 o - ooo f o
                    o r ooo t o                 o t ooo r o
                    o o ooo o o ----------->    o o ooo o o
                    o m ooo   o                 o   ooo m o
                    o   ooo   o                 o   ooo   o
                    ooooooooooo                 ooooooooooo
                    ooooooooooo                 ooooooooooo
            
            </summary>
            <param name="original">the original matrix, before the column exchange</param>
            <param name="from">the position of the column to be moved</param>
            <param name="to">the position of the destination where to move the column</param>
            <param name="isOnColumn"> this is a flag-parameter, which is neither evaluated. Its mere presence indicates that the exchange indexes indicate columns.</param>
        </member>
        <member name="M:LinearAlgebra.MatrixRank.Finalize">
            <summary>
            Destructor: it frees the memory of the underlying matrix.
            </summary>
        </member>
        <member name="M:LinearAlgebra.MatrixRank.Rango">
            <summary>
            dimensione del massimo minore nonnullo. Ovvero numero di linee della piu' grande sottomatrice quadrata, a determinante nonnullo.
            La matrice analizzata (i.e. sourceMat) puo' essere rettangolare, con dimensioni qualsiasi. Il massimo rango possibile e' la minore
            delle dimensioni della matrice analizzata.
            Il caso di matrice in esame rettangolare, costituisce il caso generale. Da esso vengono prodotti molteplici sottocasi di matrice quadrata.
            Lo entry point del Rango deve quindi essere una funzione che smista dal caso generale, di input rettangolare, al caso semplificato di input quadrato
            Il caso di primo input gia' quadrato, permette soluzione diretta, mediante il medesimo metodo di individuazione delle sottomatrici, utilizzato per i cofattori dell'inversa.
            Il caso di primo input rettangolare, richiede invece un'iterazione, per la produzione di tutti i sottocasi quadrati, fino ad individuazione del primo minore nonnullo.
            Durante tale processo, sara' utilizzata la variabile "curDimension", ad indicare l'ordine delle sottomatrici quadrate in esame.
            Esaurite tutte le sottomatrici quadrate di ordine "curDimension", si passa alla produzione delle quadrate d'ordine "curDimension-1".
            Per ogni valore di "curDimension"=="k", si hanno (n k) (i.e. "n" bionomioNewton "k") quadrate kXk, estratte da una rettangolare nXk, con n>k.
            Nel caso si parta gia' da una quadrata kXk, si deve in primis calcolarne il determinante. Ove esso sia nullo si opera "--curDimension" e cosi' via.
            Le sottofunzioni ad oggi(2015.09.02) individuate sono:
            -   selezione di "curDimension": distingue i casi quadrata-rettangolare e imposta "curDimension"
            -   "producer" : genera la sottomatrice da analizzare( combinando colonne)
            -   "ePermutazioneDi" : valuta se una certa sequenza di indici di colonna sia una permutazione di una gia' valutata; si serve della sottofunzione "appartieneA"
            -   "appartieneA" : prende uno scalare, indice di una colonna, e dice se appartiene ad una collezione di indici di colonna, ricevuta a parametro. E' una funzione elementare, con 
                schema {1}appartieneA({1,2,3})==true; {7}appartieneA({1,2,3})==false; la precedente funzione "ePermutazioneDi", va implementata considerando il risultato booleano cumulativo 
                di "appartieneA", ovvero: {1,3,2}"ePermutazioneDi"({1,2,3})==({1}appartieneA({1,2,3})and{2}appartieneA({1,2,3})and{3}appartieneA({1,2,3}) ).
            </summary>
            <returns></returns>
        </member>
        <member name="M:LinearAlgebra.MatrixRank.gestioneQuadrata(LinearAlgebra.MatrixRank)">
            <summary>
            gestioneQuadrata
            </summary>
            <returns></returns>
        </member>
        <member name="M:LinearAlgebra.MatrixRank.sottomatriciTelescopiche(LinearAlgebra.RealMatrix)">
            <summary>
            metodo ricorsivo che, partendo da una nxn, trova tutte le sottomatrici kxk, con k in [1, n-1].
            </summary>
            <param name="quadrataAnalizzanda"></param>
            <returns></returns>
        </member>
        <member name="M:LinearAlgebra.MatrixRank.gestioneRettangolare(LinearAlgebra.MatrixRank)">
            <summary>
            Tiene costanti tutti gli indici di colonna, tranne uno. Su questo itera, attribuendo tutti gli indici del range(i.e. la dimensione massima fra le due; a valle della 
            trasposizione e' l'indice delle colonne>righe).
            Cosi' facendo produce configurazioni, che vanno date in esame a "selettore", per verificare che siano effettivamente nuove.
            Data una rettangolare nXk (con n>k; in caso sia kxn si traspone, senza effetti sui minori), ci sono n_binomio_k combinazioni semplici( i.e. senza ripetizione)
            delle "n" colonne, prese "k" a "k".
            il producer implementa i cicli necessari a combinare gli indici di colonna; ad ogni combinazione prodotta, entra in azione il selettore, per stabilire se tale
            configurazione sia da utilizzare( ovvero calcolarne il determinante) o da scartare.
            Solo nel caso il selettore risponda di utilizzare la configuazione, essa viene restituita sotto forma di LinearAlgebra.RealMatrix; altrimenti si fa "continue" nei
            cicli di produzione. Osservazione: quando viene prodotta una sottomatrice quadrata, essa viene lavorata sino al piu' piccolo dei suoi minori e qundi viene associato
            il rango di tale sottomatrice, al vettore di indici della sua configurazione. Sarebbe problematico esplorare solo la "curDimension" e poi dover tornare sulla medesima
            configurazione, quando fosse intervenuto un "--curDimension".
            </summary>
        </member>
        <member name="M:LinearAlgebra.MatrixRank.producer(System.Int32[])">
            <summary>
            produce a configuration int[]
            NB. la configurazione presente, deve essere passata uguale alla precedente, in quanto sia l'incremento naturale che la ristrutturazione, vengono fatte a 
            partire dalla configurazione precedente. 
            </summary>
        </member>
        <member name="M:LinearAlgebra.MatrixRank.factUlong(System.UInt64)">
            <summary>
            fattoriale
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:LinearAlgebra.MatrixRank.fact(System.Int32)">
            <summary>
            fattoriale
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:LinearAlgebra.MatrixRank.binomioNewton(System.UInt64,System.UInt64)">
            <summary>
            cardinalita delle combinazioni senza ripetizione, di "n" elementi, presi "k" a "k" (k_smallerOrEqual_n)
            </summary>
            <param name="n">totale elementi</param>
            <param name="k">cardinalita del raggruppamento </param>
            <returns></returns>
        </member>
        <member name="M:LinearAlgebra.MatrixRank.binomioNewton(System.Int32,System.Int32)">
            <summary>
            cardinalita delle combinazioni senza ripetizione, di "n" elementi, presi "k" a "k" (k_smallerOrEqual_n)
            </summary>
            <param name="n">totale elementi</param>
            <param name="k">cardinalita del raggruppamento </param>
            <returns></returns>
        </member>
        <member name="T:LinearAlgebra.MatrixRank.SquareSmallerRank">
            <summary>
            classe utilizzata per individuare le combinazioni semplici(i.e. senza ripetizione) di colonne, costituenti le sottomatrici quadrate, di una rettangolare.
            </summary>
        </member>
        <member name="F:LinearAlgebra.MatrixRank.SquareSmallerRank.columnIndexes">
            <summary>
            column indexes, of present minor.
            </summary>
        </member>
        <member name="F:LinearAlgebra.MatrixRank.SquareSmallerRank.Rank">
            <summary>
            det of present minor.
            </summary>
        </member>
        <member name="M:LinearAlgebra.MatrixRank.SquareSmallerRank.#ctor(System.Int32)">
            <summary>
            Ctor
            </summary>
            <param name="columnCardinality"></param>
        </member>
        <member name="T:LinearAlgebra.MatrixRank.SmallerDet">
            <summary>
            a class used to classify minors, in the context of "gestioneQuadrata".
            </summary>
        </member>
        <member name="F:LinearAlgebra.MatrixRank.SmallerDet.SubMatrixSize">
            <summary>
            the number of Get_rows==Get_cols, in the present square tensor.
            </summary>
        </member>
        <member name="F:LinearAlgebra.MatrixRank.SmallerDet.SubMatrix">
            <summary>
            current Submatrix, in Smaller Det procedure.
            </summary>
        </member>
        <member name="F:LinearAlgebra.MatrixRank.SmallerDet.Det">
            <summary>
            det of present minor.
            </summary>
        </member>
        <member name="M:LinearAlgebra.MatrixRank.SmallerDet.#ctor(System.Int32,LinearAlgebra.RealMatrix,System.Double)">
            <summary>
            Ctor
            </summary>
            <param name="columnCardinality">matrix size</param>
            <param name="SubMatrix">the SubMatrix</param>
            <param name="Det">determinant</param>
        </member>
        <member name="T:LinearAlgebra.MatrixRank.CombinationParams">
            <summary>
            an internal class, to manage the combination mechanics.
            </summary>
        </member>
        <member name="F:LinearAlgebra.MatrixRank.CombinationParams.leftMostPivoter">
            <summary>
            pivotano tutti gli indici, dal leftMostPivoter verso destra.
            </summary>
        </member>
        <member name="F:LinearAlgebra.MatrixRank.CombinationParams.assignableMaxima">
            <summary>
            ciascuna colonna ha un massimo indice assegnabile, dipendente dalla posizione della colonna.
            </summary>
        </member>
        <member name="F:LinearAlgebra.MatrixRank.CombinationParams.indexRange">
            <summary>
            // ciascun indice puo' assumere valori in [naturalIndex[i], assignableMaxima[i]]
            </summary>
        </member>
        <member name="F:LinearAlgebra.MatrixRank.CombinationParams.naturalIndexes">
            <summary>
            // ciascun indice puo' assumere valori in [naturalIndex[i], assignableMaxima[i]]
            </summary>
        </member>
        <member name="F:LinearAlgebra.MatrixRank.CombinationParams.thePivotingColumn">
            <summary>
            for each position, the naturalIndex is the position itsefl.
            </summary>
        </member>
        <member name="F:LinearAlgebra.MatrixRank.CombinationParams.cardinalitaColonne">
            <summary>
            la maggiore delle dimensioni
            </summary>
        </member>
        <member name="F:LinearAlgebra.MatrixRank.CombinationParams.cardinalitaRighe">
            <summary>
            la minore delle dimensioni
            </summary>
        </member>
        <member name="M:LinearAlgebra.MatrixRank.CombinationParams.#ctor(LinearAlgebra.MatrixRank)">
            <summary>
            Ctor() init all.
            </summary>
            <param name="rettangolareAnalizzanda"></param>
        </member>
        <member name="T:LinearAlgebra.PointR2">
            <summary>
            a point in the plane.
            </summary>
        </member>
        <member name="M:LinearAlgebra.PointR2.#ctor(System.Double,System.Double)">
            <summary>
            Ctor
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:LinearAlgebra.PointR2.scalarProduct(LinearAlgebra.PointR2)">
            <summary>
            scalar product between this and w.
            </summary>
            <param name="w">the second factor; the first factor is "this"</param>
            <returns></returns>
        </member>
        <member name="M:LinearAlgebra.PointR2.vectorProduct(LinearAlgebra.PointR2)">
            <summary>
            vector product between this and w, assuminig both in the x-y plane, i.e. z==0.
            </summary>
            <param name="w">the second factor; the first factor is "this"; the result will have the form (0,0,k) with k in R.</param>
            <returns></returns>
        </member>
        <member name="P:LinearAlgebra.PointR2.getX">
            <summary>
            read-only x coordinate.
            </summary>
        </member>
        <member name="P:LinearAlgebra.PointR2.getY">
            <summary>
            read only y coordinate
            </summary>
        </member>
        <member name="P:LinearAlgebra.PointR2.getCoordinates">
            <summary>
            get the two coordinates, together.
            </summary>
        </member>
        <member name="T:LinearAlgebra.RepresentationTechniques">
            <summary>
            Engine interface:
            the sons will implement their constructors. This father is not buildable.
            </summary>
        </member>
        <member name="M:LinearAlgebra.RepresentationTechniques.representedPoint(System.Double[])">
            <summary>
            This method will be implemented by each son, to realize the proprer algorithm
            </summary>
            <param name="toBeRepresentedPoint">these are the three coordinates of the point on the variety</param>
            <returns>the three coordinates of the point on the projection board. One of these three coordinates
            can be discarded when plotting the point on a device. It's interesting to test which
            coordinate elimination damages less the perspective rendering. As a rule of thumb, if the board-plane
            lies in parallel to a coordinate plane the projected points will be constant in one coordinate.
            Such coordinate surely stores less perspective information than the other two.
            In case the three coordinates vary together a test is necessary to understand the 
            figure-specific geometry. Enjoy. :-)
            </returns>
        </member>
        <member name="T:LinearAlgebra.Geometry_inR3">
            <summary>
            Geometry_inR3 is a class that exposes static calculation methods
            for affine geometry in the ordinary space.
            No class-wise or instance-wise data is needed, so all of the involved data is exchanged
            through input-parameters and return-value, by each method.
            Each method is static. There is nothing to instantiate.
            </summary>
        </member>
        <member name="M:LinearAlgebra.Geometry_inR3.parametricLineForTwoPoints(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            equazioni parametriche della retta per due punti
            </summary>
            <param name="ax">coordinate x of point a</param>
            <param name="ay">coordinate y of point a</param>
            <param name="az">coordinate z of point a</param>
            <param name="bx">coordinate x of point b</param>
            <param name="by">coordinate y of point b</param>
            <param name="bz">coordinate z of point b</param>
            <returns>the result will be stored in the format {{a*t, x0},  {b*t, y0}, {c*t, z0} }</returns>
        </member>
        <member name="M:LinearAlgebra.Geometry_inR3.cartesianLineForTwoPoints(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            equazioni cartesiane dei due piani generatori di una retta.
            i.e. equazioni cartesiane di due piani, appartenenti al fascio proprio generato da una retta, individuata da due suoi punti.
            </summary>
            <param name="ax">coordinate x of point a</param>
            <param name="ay">coordinate y of point a</param>
            <param name="az">coordinate z of point a</param>
            <param name="bx">coordinate x of point b</param>
            <param name="by">coordinate y of point b</param>
            <param name="bz">coordinate z of point b</param>
            <returns>the result will be stored in the format {{a*x, b*y, c*z, d}, {e*x, f*y, g*z, h}}</returns>
        </member>
        <member name="M:LinearAlgebra.Geometry_inR3.parametricPlanFromCartesianPlan(System.Double[])">
            <summary>
              Metodo che genera le equazioni parametriche di un piano a partire dalla equazione cartesiana.
              The result will be stored in the form:
            			   { x:{a*t, b*u, c},
            				 y:{d*t, e*u, f},
            				 z:{g*t, h*u, i}   }
             particularly the Monge parametrization will be used, which is a map where a coordinate
             function dependes monodromically on the other parameters, each of which is explicit.
             such parametrization assumes the form:
             x = x(t,u) = t
             y = y(t,u) = u
             z = z(t,u) = f(x,y) = f(x(t,u),y(t,u))= f(t,u)
            
             nevertheless in the input cartesian plane equation some of the coefficients may be zero.
             So as first will be located the first non-zero coefficient, then the others will be made
             explicit using this denominator. Suppose that in the equation ax+by+cz+d=0 c is not zero.
             Then z = (-a/c)*x + (-b/c)*y + (-d/c)
             { {(-a/c)}, {(-b/c)}, {(-d/c)} } this is the "ratios' array", where "c" will be the
            first non-zero coefficient.
            </summary>
            <param name="cartesianPlan">the equation ax+by+cz+d=0</param>
            <returns>the result will be stored in the form:
            		   { x:{a*t, b*u, c},
            			 y:{d*t, e*u, f},
            	 		 z:{g*t, h*u, i}   }
            </returns>
        </member>
        <member name="M:LinearAlgebra.Geometry_inR3.complanaritaThreeR3Points(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            se tre vettori di R3 sono linearmente dipendenti, sono complanari.
            </summary>
            <param name="ax">coordinate x of point a</param>
            <param name="ay">coordinate y of point a</param>
            <param name="az">coordinate z of point a</param>
            <param name="bx">coordinate x of point b</param>
            <param name="by">coordinate y of point b</param>
            <param name="bz">coordinate z of point b</param>
            <param name="cx">coordinate x of point c</param>
            <param name="cy">coordinate y of point c</param>
            <param name="cz">coordinate z of point c</param>
            <returns>bool</returns>
        </member>
        <member name="M:LinearAlgebra.Geometry_inR3.parametricPlaneThroughThreePoints_withoutNormalization(System.Double[],System.Double[],System.Double[])">
            <summary>
            equazioni parametriche del piano, per tre vettori linermente indipendenti.
            </summary>
            <param name="directionCosine_A">coordinates of the vector point a</param>
            <param name="directionCosine_B">coordinates of the vector point b</param>
            <param name="translation">coordinates of the vector point translation</param>
            <returns>the result will be stored in the form:
                {
            	    x(t,u)== t*ax + u*bx + cx
            	    y(t,u)== t*ay + u*by + cy
            	    z(t,u)== t*az + u*bz + cz
            	}
            </returns>
        </member>
        <member name="M:LinearAlgebra.Geometry_inR3.parametricPlaneThroughThreePoints_Normalized(System.Double[],System.Double[],System.Double[])">
            <summary>
            
            </summary>
            <param name="directionCosine_A_preNormalization"></param>
            <param name="directionCosine_B_preNormalization"></param>
            <param name="translation"></param>
            <returns></returns>
        </member>
        <member name="M:LinearAlgebra.Geometry_inR3.cartesianPlaneThroughThreePoints_withoutNormalization(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            equazione cartesiana di un piano per tre punti non allineati; in questo metodo i tre punti sono qualsiasi terna di vettori linearmente indipendenti.
            </summary>
            <param name="ax">coordinate x of point a</param>
            <param name="ay">coordinate y of point a</param>
            <param name="az">coordinate z of point a</param>
            <param name="bx">coordinate x of point b</param>
            <param name="by">coordinate y of point b</param>
            <param name="bz">coordinate z of point b</param>
            <param name="cx">coordinate x of point c</param>
            <param name="cy">coordinate y of point c</param>
            <param name="cz">coordinate z of point c</param>
            <returns>the return value is a double[4] array, whose elements are the coefficiens of the cartesian plane equation;
            (in the order {x,y,z,k} where k is the traslation term )</returns>
        </member>
        <member name="M:LinearAlgebra.Geometry_inR3.cartesianPlaneThroughThreePoints_Normalized(LinearAlgebra.PointR3,LinearAlgebra.PointR3)">
            <summary>
            equazione cartesiana di un piano per tre punti non allineati, uno dei quali e' l'origine: quindi un piano vettoriale.
            NB. uno dei tre punti deve essere il comune punto di applicazione degli altri due; qualora cosi'
            non fosse, deve preoccuparsi chi chiama questa funzione, di rendere tali i parametri, mediante sottrazione. Per convenzione di assume che il punto di applicazione sia il vettore
            (cx, cy, cz). Pertanto in uno spazio vettoriale si possono passare i vettori "a" e "b", intesi applicati nell'origine, ed il vettore nullo come "c". Qualora invece "c" fosse
            nonnullo, si dovra' passare (a-c),(b-c),(c-c)==(a-c),(b-c),(0).
            </summary>
            <returns>the return value is a double[4] array, whose elements are the coefficiens of the cartesian plane equation;
            (in the order {x,y,z,k} where k is the traslation term )</returns>
        </member>
        <member name="M:LinearAlgebra.Geometry_inR3.PointImageInR3_ofParametricPlan_fromParametersR2Point(System.Double[0:,0:],System.Double[])">
            <summary>
            this method calculates the R3 coordinates of a point, belonging to a plane whose parametric equations
            are known. Also known are the two coordinates in the R2 space of the parameters (the (t,u) parameters
            that describe the plane in the parametrization {{x=x(t,u)},{y=y(t,u)},{z=z(t,u)}}
            </summary>
            <param name="planParametricEquations">the parametrization {{x=x(t,u)},{y=y(t,u)},{z=z(t,u)}}</param>
            <param name="parametersR2Point">the two coordinates in the R2 space of the parameters: the (t,u) parameters</param>
            <returns>the three coordinates in the R3 space of the plane-immersion: the {x,y,z} coordinates, where {{x=x(t,u)},{y=y(t,u)},{z=z(t,u)}}</returns>
        </member>
        <member name="M:LinearAlgebra.Geometry_inR3.intersectionPointBetweenCartesianLineAndCartesianPlane(System.Double[],System.Double[],System.Double[])">
            <summary>
            this method considers the case of a line, neither belonging to a plane nor in parallel with it.
            such line has one and only one intersection point with the plane. This is obtained by means of 
            a non-omogeneous( in general. Some times it could be but in this case the solution is trivially
            the null-vector) liner system 3x3. Ax=b, where A is the 3x3 matrix of the cartesian coefficients.
            These are the three coordinates coefficients in the three input-cartesian-equations.
            So the system is composed of the director-cosines of the considered plane and of the 
            two planes which individuate the line. Note that this system has the same solution if the 
            equations are changed of order, since it changes also the result vector. So Ax=b is equivalent
            to (A~)x=(b~). Anyway A^(-1) and (A~)^(-1) will bw unique and multiplied (respectively) by
            b and (b~) will give the same x vector.
            Note that this method is intended for the case of incident line and plane only. If the input data
            consist of a line contained in the input plane or in parallel with it, the method will throw the
            appropriate exception.
            In the former case the exception will say that the system has one-infinity of solutions, precisely
            the aleph-one points hold by the line itself, which, being contained by the plane, solves the system
            with all herself.
            In the latter case the system presents no solution.
            </summary>
            <param name="theBoardPlane">the cartesian plane to be intersected with the line</param>
            <param name="theFirstLineGeneratingPlane">each of the two cartesian planes belonging to the proper bundle which individuates the line</param>
            <param name="theSecondLineGeneratingPlane">each of the two cartesian planes belonging to the proper bundle which individuates the line</param>
            <returns>the coordinates of the intersection point</returns>
        </member>
        <member name="M:LinearAlgebra.Geometry_inR3.intersectionBetweenCartesianPlaneAndParametricLine(System.Double[],System.Double[0:,0:])">
            <summary>
            Composes a linear system devoted to find the intersection between plane and line.
            The linear system will be composed with the cartesian equation of the plane and 
            with the parametrization of the line.
            The expressions that the three coordinate functions assume in the line parametrization
            will be substituted in the cartesian equation of the plane.
            A value of the independent parameter will be found. Substituting such value in the
            parametric equations of the line, the three coordinate functions will assume the 
            values of the intersection-point coordinates.
            </summary>
            <param name="cartesianPlane">the three coordinate-coefficients and the traslation term</param>
            <param name="parametricLine">the three direction-cosines and the three traslation terms</param>
            <returns>the three cartesian coordinates of the intersection between plane and line</returns>
        </member>
        <member name="M:LinearAlgebra.Geometry_inR3.parametricLineSubjectToAnAffinity(System.Double[0:,0:],System.Double[])">
            <summary>
            the algorithm consists of preserving the directive-cosines and applying an affinity,
            to let a line in parallel to the input one, but passing through the desired point.
            If the input line has equation:
            {{a*t, x0},
             {b*t, y0},
             {c*t, z0} }
             and the desired point has coordinates {xw,yw,zw}
             then the resulting line will have parametric equations:
            {{a*t, xw},
             {b*t, yw},
             {c*t, zw} }
            </summary>
            <param name="originalParametricLine">the desired orientation</param>
            <param name="pointToPassThrough">the point to pass through</param>
            <returns>the parametric equations of the line, having the same orientation of
            the originalParametricLine, but passing through the pointToPassThrough</returns>
        </member>
    </members>
</doc>
